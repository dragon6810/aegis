#include "portal.h"

bspnode_t outsidenode;

portal_t* AllocPortal()
{
    return (portal_t*) calloc(1, sizeof(portal_t));
}

void HeadnodePortals(bspnode_t* head)
{
	int i, j, n;

    vec3_t min, max;
    vec3_t mins[3], maxs[3];

    portal_t* portals[6];
    portal_t* p;

    SurfListBB(head->plane->childsurfs[0], &mins[0], &maxs[0]);
    SurfListBB(head->plane->surfs, &mins[1], &maxs[1]);
    SurfListBB(head->plane->childsurfs[1], &mins[2], &maxs[2]);

    for (i = 0; i < 3; i++)
    {
        min[i] = mins[0][i] < mins[1][i] && mins[0][i] < mins[2][i] ? mins[0][i] : mins[1][i] < mins[2][i] ? mins[1][i] : mins[2][i]; // what the fuck
        max[i] = maxs[0][i] > maxs[1][i] && maxs[0][i] > maxs[2][i] ? maxs[0][i] : maxs[1][i] > maxs[2][i] ? maxs[1][i] : maxs[2][i];

        min[i] -= 24;
        max[i] += 24;
    }

    outsidenode.leaf->contents = CONTENTS_SOLID;
    outsidenode.portals = 0;

    for (i = 0; i < 3; i++)
    {
        for (j = 0; j < 2; j++)
        {
            n = j * 3 + i;

            p = AllocPortal();
            portals[n] = p;

            if (j)
            {
                p->pl.n[i] = -1;
                p->pl.d = -max[i];
            }
            else
            {
                p->pl.n[i] = 1;
                p->pl.d = min[i];
            }

            p->poly = AllocPoly();
            HungryPoly(p->poly, p->pl.n, p->pl.d);
        }
    }
}

void Portalize(bspnode_t* head)
{
	HeadnodePortals(head);
}