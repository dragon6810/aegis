#include <stdio.h>

#include <argparse/argparse.hpp>

#include <maplib.h>
#include <utilslib.h>

#include "Bsp.h"
#include "Csg.h"

int nbrush = 0;
int nbrface = 0;

void ProcessModel(model_t *mdl, bool world)
{
    CsgModel(mdl);
    BspModel(mdl);
}

void LoadBrush(Maplib::brush_t *fbr, brush_t *outbr)
{
    int i;

    brface_t *pl;
    Maplib::plane_t *fpl;
    Eigen::Vector3f a, b, n;
    float d;

    assert(fbr);
    assert(outbr);

    outbr->faces.resize(fbr->planes.size());
    for(i=0; i<fbr->planes.size(); i++)
    {
        pl = &outbr->faces[i];
        fpl = &fbr->planes[i];

        *pl = {};

        a = (fpl->triplane[1] - fpl->triplane[0]).cast<float>();
        b = (fpl->triplane[2] - fpl->triplane[0]).cast<float>();
        n = a.cross(b).normalized();
        d = n.dot(fpl->triplane[0].cast<float>());

        pl->planenum = FindPlane(n, d);
        if(pl->planenum < 0)
        {
            pl->flip = true;
            pl->planenum = ~pl->planenum;
        }
        pl->texinfo = FindTexinfo(fpl->texname.c_str(), fpl->texbasis, fpl->texoffs);

        nbrface++;
    }

    nbrush++;
}

int LoadModel(Maplib::entity_t *fent)
{
    int i;

    model_t *mdl;

    assert(fent);
    assert(fent->brushes.size());

    models.push_back({});
    mdl = &models.back();

    mdl->brushes[0].resize(fent->brushes.size());
    for(i=0; i<mdl->brushes[0].size(); i++)
        LoadBrush(&fent->brushes[i], &mdl->brushes[0][i]);

    return models.size() - 1;
}

void LoadEnt(Maplib::entity_t *fent)
{
    entity_t *ent;

    assert(fent);

    ents.push_back({});
    ent = &ents.back();

    ent->pairs = fent->keys;
    if(!fent->brushes.size())
        return;

    ent->model = true;
    ent->modelnum = LoadModel(fent);
}

void LoadMap(const char* file)
{
    int i;

    Maplib::MapFile map;
    uint64_t startt, endt;

    startt = TIMEMS;

    printf("---- LoadMap ----\n");

    map = Maplib::MapFile::Load(file);
    if(!map.ents.size())
    {
        printf("map loading failed for file \"%s\".\n", file);
        exit(1);
    }

    ents.reserve(map.ents.size());
    for(i=0; i<map.ents.size(); i++)
        LoadEnt(&map.ents[i]);
    
    endt = TIMEMS;
    printf("LoadMap done in %llums.\n", endt - startt);
    
    if(verbose)
    {
        printf("%d entities.\n", ents.size());
        printf("%d models.\n", models.size());
        printf("%d brushes.\n", nbrush);
        printf("%d brush faces.\n", nbrface);
    }
}

int main(int argc, char** argv)
{
    int i;

    argparse::ArgumentParser argparser("bspgen", "0.1.0", argparse::default_arguments::help, false);
    std::string infile, outfile, hullfile;

    argparser.add_argument("-v", "--verbose").flag();
    argparser.add_argument("--csg-output").help("output the geometry generated by CSG into an OBJ file");
    argparser.add_argument("--hull-definition").help("an file to override the default hulls definitions");

    argparser.add_argument("mapfile").help("the map file to use as input").required();
    argparser.add_argument("-o", "--output").help("the bsp file to use as output");

    try
    {
        argparser.parse_args(argc, argv);
    }
    catch(const std::exception& err)
    {
        fprintf(stderr, "%s\n", err.what());
        std::cerr << argparser; // i hate doing this >:(
        return 1;
    }

    infile = argparser.get("mapfile");
    infile = Utilslib::DefaultExtension(infile.c_str(), "map");
    if(argparser.present("--output"))
    {
        outfile = argparser.get("--output");
        outfile = Utilslib::DefaultExtension(outfile.c_str(), "bsp");
    }
    else
    {
        outfile = Utilslib::StripExtension(infile.c_str());
        outfile = Utilslib::AddExtension(outfile.c_str(), "bsp");
    }

    verbose = argparser["--verbose"] == true;
    if(argparser.present("--csg-output"))
        objout = argparser.get("--csg-output");

    if(argparser.present("--hull-definition"))
    {
        hullfile = argparser.get("--hull-definition");
        hullfile = Utilslib::DefaultExtension(hullfile.c_str(), "hul");
        if(!hulls.LoadFile(hullfile.c_str()))
            return 1;
    }

    LoadMap(infile.c_str());
    for(i=0; i<models.size(); i++)
        ProcessModel(&models[i], !i);

    return 0;
}